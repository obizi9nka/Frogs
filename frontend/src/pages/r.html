Код для тестирования функции в интерфейсе HTML с использованием Ether.js:
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Test deposit function</title>
    <script src="https://cdn.ethers.io/v5.2.0-beta.0/ethers.min.js"
        integrity="sha384-/ijC0HogvGmyJFB63q3GcRKti9WJZz6OI1x2UdR6UkOJ8yv6UUGuEKLJ0RXhCsZ5"
        crossorigin="anonymous"></script>
</head>

<body>
    <h1>Deposit Function Test</h1>
    <label for="amountToken">Amount of Token0 to deposit:</label>
    <input type="number" id="amountToken" name="amountToken"><br><br>
    <label for="amountETH">Amount of ETH to deposit:</label>
    <input type="number" id="amountETH" name="amountETH"><br><br>
    <button onclick="deposit()">Deposit</button>
    <script>
        var cakeContractAddress = '\"<insert cake contract address>"';
        var frogReferalAddress = '\"<insert frog referal address>"';
        var pancakeRouterAddress = "<insert pancake router address>";
        var bnbContractAddress = "<insert bnb contract address>";
        var usdtContractAddress = '\"<insert usdt contract address>"';
        var pancakePairAddress = '\"<insert pancake pair address>"';
        var pancakeMCAddress = '\"<insert pancake masterchef address>"';
        var pancakePID = '\"<insert pancake pool ID>"';
        var minUsdt = '<insert minUSDT>';
        var maxUsdt = ' <insert maxUSDT>';
        var lpDecimals = '<insert lp decimals>';
        var balanceOf = {};
        var depositOf = {};
        var withdrawOf = {};
        var participants = [];
        var alreadyParticipant = {};

        // Function to get PS rate
        function getPSRate(amount, token0, token1) {
            return 2 * amount / (getAmountsOut(amount, token0, token1) + getAmountsIn(amount, token0, token1));
        }

        // Function to get amounts out
        async function getAmountsOut(amount, token0, token1) {
            const pair = await ethers.getContractAt("IPancakePair", pancakePairAddress);
            const amountsOut = await pair.getAmountsOut(amount, [token0, token1]);
            return amountsOut[1];
        }

        // Function to get amounts in
        async function getAmountsIn(amount, token0, token1) {
            const pair = await ethers.getContractAt("IPancakePair", pancakePairAddress);
            const amountsIn = await pair.getAmountsIn(amount, [token0, token1]);
            return amountsIn[0];
        }

        // Function to get LP tokens rate
        async function rateLPTokens() {
            const pair = await ethers.getContractAt("IPancakePair", pancakePairAddress);
            const reserves = await pair.getReserves();
            return [reserves[0], reserves[1]];
        }

        // Function to check if user is already participant
        function isParticipant(user) {
            return alreadyParticipant[user];
        }

        // Deposit function
        async function deposit() {
            var amountToken0 = document.getElementById("amountToken").value;
            var amountToken1 = document.getElementById("amountETH").value;
            var signer = new ethers.providers.Web3Provider(web3.currentProvider).getSigner();

            // Checking token0 balance
            const cakeToken = await ethers.getContractAt("IERC20", cakeContractAddress);
            const balance = await cakeToken.balanceOf(signer.getAddress());
            if (balance.lt(amountToken0)) {
                console.log("Not enough Token0");
                return false;
            }

            // Checking token0 allowance
            const allowance = await cakeToken.allowance(signer.getAddress(), "<insert this contract address>");
            if (allowance.lt(amountToken0)) {
                console.log("Not enough allowance for Token0");
                return false;
            }

            // Checking if user is participant
            if (!isParticipant(signer.getAddress())) {
                const frogReferal = await ethers.getContractAt("IFrogReferal", frogReferalAddress);
                const isPart = await frogReferal.isParticipant(signer.getAddress());
                if (!isPart) {
                    console.log("User is not a participant in FrogReferal");
                    return false;
                }
            }

            // Checking USDT balance
            const usdtToken = await ethers.getContractAt("IERC20", usdtContractAddress);
            const usdtBalance = await usdtToken.balanceOf(signer.getAddress());

            // Checking minUSDT and maxUSDT
            const [lpToken0, lpToken1] = await rateLPTokens();
            var futureBalanceUsdt = (balanceOf[signer.getAddress()] + depositOf[signer.getAddress()] - withdrawOf[signer.getAddress()]) * (getPSRate(lpToken0, cakeContractAddress, usdtContractAddress) + getPSRate(lpToken1, bnbContractAddress, usdtContractAddress)) / lpDecimals;
            var depositUsdt = getPSRate(amountToken0, cakeContractAddress, usdtContractAddress) + getPSRate(amountToken1, bnbContractAddress, usdtContractAddress);
            if (futureBalanceUsdt + depositUsdt < minUsdt) {
                console.log("Total balance less than minUSDT");
                return false;
            }
            if (futureBalanceUsdt + depositUsdt > maxUsdt) {
                console.log("Total balance great than maxUSDT");
                return false;
            }

            // Transfer token0 from user to contract
            const tx1 = await cakeToken.transferFrom(signer.getAddress(), pancakePairAddress, amountToken0);
            const receipt1 = await tx1.wait();
            if (receipt1.status !== 1) {
                console.log("Token0 transfer failed");
                return false;
            }

            // Approve token0 for pancake router
            const tx2 = await cakeToken.approve(pancakeRouterAddress, amountToken0);
            const receipt2 = await tx2.wait();
            if (receipt2.status !== 1) {
                console.log("Token0 approve failed");
                return false;
            }

            // Add liquidity for LP tokens
            const pancakeRouter = await ethers.getContractAt("IPancakeRouter02", pancakeRouterAddress);
            const [exactToken0Amount, exactToken1Amount] = [amountToken0, amountToken1];
            const deadline = Math.floor(Date.now() / 1000) + 20 * 60;
            const tx3 = await pancakeRouter.addLiquidityETH(cakeContractAddress, exactToken0Amount, exactToken0Amount / 10000 * 9900, exactToken1Amount / 10000 * 9900, signer.getAddress(), deadline, { value: amountToken1 });
            const receipt3 = await tx3.wait();
            if (receipt3.status !== 1) {
                console.log("Add liquidity failed");
                return false;
            }

            // Approve LP tokens for Pancake MC
            const lpTokenAmount = await ethers.getContractAt("IERC20", pancakePairAddress).balanceOf(signer.getAddress());
            const tx4 = await ethers.getContractAt("IERC20", pancakePairAddress).approve(pancakeMCAddress, lpTokenAmount);
            const receipt4 = await tx4.wait();
            if (receipt4.status !== 1) {
                console.log("LP token approve failed");
                return false;
            }

            // Deposit LP tokens to Pancake MC
            const pancakeMC = await ethers.getContractAt("IMasterChef", pancakeMCAddress);
            const tx5 = await pancakeMC.deposit(pancakePID, lpTokenAmount);
            const receipt5 = await tx5.wait();
            if (receipt5.status !== 1) {
                console.log("Deposit to MasterChef failed");
                return false;
            }

            // Update balances and participants
            depositOf[signer.getAddress()] += lpTokenAmount;
            if (!isParticipant(signer.getAddress())) {
                alreadyParticipant[signer.getAddress()] = true;
                participants.push(signer.getAddress());
                console.log("New participant added");
            }

            console.log("Deposit successful");
            return true;
        }
    </script>
</body>

</html>